### 算法工具


#### Pytorch vs tensorflow

- 差异点对比如下
    - 创建和运行计算图可能是两个框架最不同的地方

| 工具 | **介绍** | 优缺点 | 灵活性 | 设备管理 | 应用场景 | 是否推荐
|:- | :- | :- | :-| :-| :- | :-
| pytorch  | **图结构是动态的**，这意味着图在运行时构建 | 简单的图结构更容易理解，且更容易调试，使用pdb即可 | 动态计算图，数据参数在CPU与GPU之间迁移十分灵活，调试简便；| 需要明确启用的设备 | 图像（检测、分类等）<br> 文（NLP） <br> 强化学习  | 推荐
| tensorflow   | **图结构是静态的**，这意味着图先被“编译”然后再运行 | 调试tensorFlow代码不容易，<br> 1. 从会话请求要检查的变量；2. 使用tensorFlow的调试器（tfdbg） | 静态计算图，数据参数在CPU与GPU之间迁移麻烦，调试麻烦。语言过于底层 | 不需要手动调整，简单| 基于文本的应用程序：语言检测、文本摘要<br>图像识别：图像字幕、人脸识别、物体检测 <br> 声音识别时间序列分析<br>视频分析
|Keras| **图结构是静/动态，可配置** <br>keras是用Python编写的，可以运行在TensorFlow（以及CNTK和Theano）之上。Keras支持卷积神经网络和递归神经网络。它可以在CPU和GPU上无缝运行。 | Keras是一个高级API，开发的重点是实现快速实验
| Caffee | Caffe是面向图像处理领域的另一种流行的深度学习框架。Caffe为C、C++、Python、Matlab等接口以及传统的命令行提供了坚实的支持。 |  | 不够灵活，同时内存占用高。
| Theano |由蒙特利尔理工学院2008年开发，派生出了大量深度学习python软件包。包括Blocks和**keras**。Theano的核心是一个数学表达式的编译器，他知道如何获取你的结构，并使之成为一个使用numpy，高效本地库的高效代码。  |  |  | 
| MXNet |  其开放的语言接口不仅仅有python和C++，还有R，MATLAB，scala和JavaScript | 教程不够完善，使用的人不多导致社区不大 | 性能特别好，占用显存低| 



### tensorflow介绍
- 特点
    - Tensorflow是一个通过计算图的形式来表述计算的编程系统，计算图也叫数据流图，可以把计算图看做是一种有向图，
    - 一般包括两部分
        - 构造部分，包含计算流图
        - 执行部分，通过session来执行图中的计算
    - Tensorflow中的每一个计算都是计算图上的一个节点，而节点之间的边描述了计算之间的依赖关系。


### 数据库

<!-- #region -->
#### mysql vs neo4j
- 数据库概述
    - Mysql是一个关系型数据库
    - neo4j是一个图数据库，更好地也更高效地描述实体之间的关系。



| 工具 | **数据定义** | 数据查询 | 查询语句 
| :- | :-| :-| :-
| mysql  | **高度结构化的数据** | 关系查询操作耗时 | 查询语句更为复杂，尤其涉及到join或者union操作 
| neo4j | **允许对数据的简单且多样的管理**  | 常数时间的关系查询 | 提出全新的查询语言cypher，查询语句更加简单
<!-- #endregion -->

### python

<!-- #region -->
#### Python基础
1. Python到底是什么样的语言？你可以比较其他技术或者语言来回答你的问题。
    - **Python是解释型语言。这意味着不像C和其他语言，Python运行前不需要编译**
    - Python是动态类型的，这意味着你不需要在声明变量时指定类型
    - **Python是面向对象语言，所有允许定义类并且可以继承和组合**。Python没有访问访问标识如在C++中的public, private
    - 在Python中，函数是一等公民。这就意味着它们可以被赋值，从其他函数返回值，并且传递函数对象。类不是一等公民。


2. python的一些注意点？
    - 变量命名规则要一致。如果已有一些潜在的命名规则，首先要遵守它。
    - 递归要注意有递归，而且有终止。清晰这一点才能保证不会永远调用下去没有终止。
    
    
3. Python和多线程，是不是个好主意？列举你觉得可以让Python代码并行运行的方法？
    - Python实际上不允许多线程。它有一个threading包但是如果你想加快代码运行速度，或者想并行运行，这不是一个好主意。
    - **Python有一个机制叫全局解释器锁（GIL）。GIL保证每次只有一个线程在解释器中跑**。一个线程获得GIL，之后再交给下一个线程。
    - 所以，看起来是多个线程在同时跑，但是实际上每个时刻只有CPU核在跑一个线程，没有真正利用多个CPU核跑多个线程。就是说，多个线程在抢着跑一个CPU核。
    
    
4. 你怎么对你的代码进行跟踪，协同写代码？
    - 版本控制! 只是关键，你应该很兴奋地告诉他们你怎用Git的。
    - Git是我最喜欢的版本控制系统，但是也有其他的如svn等等。
    
    
5.  $*args, **kwargs$是什么东西? 我们为什么会用它？
    - $我们用 *args$ 当我们不知道要有多少个参数传给函数，或者我们想把一个列表或者tuple存起来以后传给函数。
    - $我们用**kwargs$当我们不知道有多少个关键字参数要传给函数，或者我们想把字典存起来以后传给函数。
    - args 和 kwargs的名字是以前遗留下来的，你用 $*bob 和**billy$也没关系但是这样不太好，嘿嘿。
    
    
6. @abstractmethod、@classmethod、@staticmethod、@property都是什么意思?

| 方法 | 方法说明 | 使用场景 | 特点 | 是否常用
| :-| :-| :-| :-| :-
| staticmethod | 静态方法  | 如果**不想传入self参数，并且想使用该类中的方法，或者不想实例化类**可使用 @staticmethod装饰器 | 可将其当作一般函数使用，有利于减少不必要的内存和性能消耗。| 是
| classmethod | 类方法 | 使用类方法后，类中的函数默认不传入self，而是cls | cls为类本身，也是构造函数。调用cls即为实例化该类。 | 是
| property | 属性 | 将方法转换为属性，可以使用@property装饰器来创建只读属性 @property装饰器会将方法转换为相同名称的只读属性,可以与所定义的属性配合使用，这样可以防止属性被修改。 | 将方法变成属性后，用户可以获取变量值却不知道变量真实的名称，也就不能修改了。 <br> 一般会定义相应的getter和setter，如果只定义getter而不定义setter，则是只读的啦
| abstractmethod | 抽象方法 | 使用@abstractmethod可以在方法执行前抛出。


7. 装饰器说明？
    - 1、函数是可以把另一个函数当作参数传入的； 
    - 2、一个函数内部是可以调用另一个函数的； 
    - 3、当一个函数A把另一个函数B当作参数出入,并且在内部调用了函数B,那么函数A就可以作为装饰器！
    
    
8. 简介地描述下Python的垃圾回收机制?
    - **Python在内存中维护对象的引用次数。如果一个对象的引用次数变为0，垃圾回收机制会回收这个对象作为他用。**
    - 有时候会有“引用循环”的事情发生。垃圾回收器定期检查回收内存。
        - 一个例子是，如果你有两个对象 o1 和 o2，并且o1.x == o2 and o2.x == o1. 如果 o1 和 o2 都没有被其他对象使用，那么它们都不应该存在。但是它们的应用次数都是1，垃圾回收不会起作用。
    - 一些启发算法可以用来加速垃圾回收。
        - 比如，最近创建的对象更可能是无用的。用创建时间来度量对象的生命时长，生命越长，越可能是更有用的对象。
        
        
9. Python是如何进行内存管理的？
    - 从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制
    - 引用计数机制，
        - 引用计数增加的情况：
        - 1，一个对象分配一个新名称
        - 2，将其放入一个容器中（如列表、元组或字典）
        - 引用计数减少的情况：
        - 1，使用del语句对对象别名显示的销毁
        - 2，引用超出作用域或被重新赋值
        - sys.getrefcount( )函数可以获得对象的当前引用计数
        - 多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。
    - 垃圾回收
        - 1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。
        - 2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。**为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。**
    - 内存池机制
        - **Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。**
        - 1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。
        - 2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。
        - 3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。**也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。**
        
        
10. 什么是lambda函数？它有什么好处?
    - lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数
    - lambda函数：首要用途是指点短小的回调函数
    
    
11. 介绍一下except的用法和作用？
    - 执行方式为，`try…except…except…[else…][finally…]`
    - 执行try下的语句，如果引发异常，则执行过程会跳到except语句。
    - 对每个except分支顺序尝试执行，如果引发的异常与except中的异常组匹配，执行相应的语句。如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。
    - try下的语句正常执行，则执行else块代码。如果发生异常，就不会执行
    - 如果存在finally语句，最后总是会执行。
    
    
    
12. Python里面match()和search()的区别？
    - re模块中`match(pattern,string[,flags])`,检查string的开头是否与pattern匹配。
    - re模块中`research(pattern,string[,flags])`,在string搜索pattern的第一个匹配值。
    
    
13. 用Python匹配HTML tag的时候，<.*>和<.*?>有什么区别？
    - $( <.*> )术语叫贪婪匹配和(<.*?> )叫做非贪婪匹配$
<!-- #endregion -->

<!-- #region -->
#### 线程和进程的区别
- 多线程可以共享全局变量，多进程不能
- 进程：
    - 1.操作系统进行资源分配和调度的基本单位，多个进程之间相互独立；
    - 2.稳定性好，如果一个进程崩溃，不会影响其他进程，但是进程消耗资源大，开启的进程数量有限制。


- 线程：
    - 1.CPU进行资源分配和调度的基本单位，**线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享该进程的所有资源**。
    - 2.如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程崩溃。
<!-- #endregion -->

<!-- #region -->
#### GIL锁
- $\color{red}{python对多线程不友好}$
    - $\color{blue}{python多线程并不是并行执行，因此较适合与I/O密集型程序，多进程并行执行适用于CPU密集型程序}$
    - **GIL是python的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），使该进程内的其他线程无法运行，**等该线程运行完后其他线程才能运行。
    - 如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。
    - 多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，**所以多进程可以实现多个进程的同时运行**，缺点是进程系统资源开销大


- 在python多线程下，每个线程的运行方式：
    - 1. 获取GIL；
    - 2. 执行代码直到sleep或者是python虚拟机将其挂起；
    - 3. 释放GIL。
- 多核下，想做并行提升效率，比较通用的方法是使用多进程，能够有效提高执行效率。
<!-- #endregion -->

#### copy说明
- 浅拷贝：拷贝父对象，不会拷贝对象的内部的子对象，这两个对象不是完全独立的。
- 深拷贝：copy模块的deepcopy方法，完全拷贝了父对象及其子对象，两个对象完全是独立的。
    - 修改其中一个，另外一个不会改变

<!-- #region -->
#### 可迭代对象
- 可迭代对象
    - （Iterable Object），简单的来理解就是可以使用 for 来循环遍历的对象。比如常见的 list、set和dict。
    - 可迭代对象具有__iter__ 方法，用于返回一个迭代器，或者定义了getitem方法，可以按 index 索引的对象（并且能够在没有值时抛出一个 IndexError 异常），
    - 因此，可迭代对象就是能够通过它得到一个迭代器的对象。
    - 所以，可迭代对象都可以通过调用内建的 iter() 方法返回一个迭代器。


- 生成器
    - 生成器其实是一种特殊的迭代器，不过这种迭代器更加优雅。
    - **它不需要再像上面的类一样写__iter__()和__next__()方法了，只需要一个yiled关键字。**
<!-- #endregion -->
